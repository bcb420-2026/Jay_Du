[["index.html", "worked Example Welcome", " worked Example Ruth Isserlin Welcome This mini-book introduces identifier mapping and walks through practical examples using GEO datasets: GSE233947 GSE119732 "],["what-is-identifier-mapping.html", "Chapter 1 What is identifier mapping? 1.1 Visual overview", " Chapter 1 What is identifier mapping? Identifier mapping is translating between different ways of naming the same biological entity. Common situations: Data uses stable IDs (e.g., Ensembl gene IDs) Downstream tools want gene symbols (e.g., HGNC) Some assays use non-gene identifiers (probes, peptides, genomic coordinates) 1.1 Visual overview "],["getting-data-from-geo.html", "Chapter 2 Getting data from GEO", " Chapter 2 Getting data from GEO We download GEO supplementary files to obtain realistic identifiers. library(GEOquery) ## Loading required package: Biobase ## Loading required package: BiocGenerics ## Loading required package: generics ## ## Attaching package: &#39;generics&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, ## setequal, union ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, aperm, append, as.data.frame, basename, cbind, ## colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ## get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique, ## unsplit, which.max, which.min ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) source(&quot;./fetch_geo_supp.R&quot;) fetch_geo_supp(gse = &quot;GSE233947&quot;) ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_FeatureCounts_V31genes_RawCounts_ENSG.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_3CTG_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_3CTG_junctions.tsv.gz fetch_geo_supp(gse = &quot;GSE119732&quot;) ## Using locally cached version of supplementary file(s) GSE119732 found here: ## data/GSE119732/GSE119732_count_table_RNA_seq.txt.gz "],["why-identifiers-are-messy.html", "Chapter 3 Why identifiers are messy", " Chapter 3 Why identifiers are messy Version suffixes: Ensembl IDs can appear as ENSG... .7 and often must be stripped. One-to-many mappings: a stable ID may map to multiple symbols (aliases/synonyms). Annotation drift: mappings depend on genome build and Ensembl/HGNC releases. Best practice: keep the stable ID as the key and add symbols as annotation columns. "],["biomart-step-by-step.html", "Chapter 4 biomaRt step-by-step 4.1 1. List marts 4.2 2. (Optional) pin an Ensembl archive version 4.3 3. List datasets and select human 4.4 4. Identify the correct filter 4.5 5. Identify the correct attributes 4.6 6. Strip version suffixes (if present) 4.7 7. Run the query with getBM() 4.8 8. Cache the mapping (recommended) 4.9 9. Merge back into your data", " Chapter 4 biomaRt step-by-step This follows the following workflow: choose a mart → choose a dataset → discover filters/attributes → query with getBM() → merge back into your matrix. library(biomaRt) 4.1 1. List marts listMarts() ## biomart version ## 1 ENSEMBL_MART_ENSEMBL Ensembl Genes 115 ## 2 ENSEMBL_MART_MOUSE Mouse strains 115 ## 3 ENSEMBL_MART_SNP Ensembl Variation 115 ## 4 ENSEMBL_MART_FUNCGEN Ensembl Regulation 115 4.2 2. (Optional) pin an Ensembl archive version listEnsemblArchives()[1:10,] ## name date url version ## 1 Ensembl GRCh37 Feb 2014 https://grch37.ensembl.org GRCh37 ## 2 Ensembl 115 Sep 2025 https://sep2025.archive.ensembl.org 115 ## 3 Ensembl 114 May 2025 https://may2025.archive.ensembl.org 114 ## 4 Ensembl 113 Oct 2024 https://oct2024.archive.ensembl.org 113 ## 5 Ensembl 112 May 2024 https://may2024.archive.ensembl.org 112 ## 6 Ensembl 111 Jan 2024 https://jan2024.archive.ensembl.org 111 ## 7 Ensembl 110 Jul 2023 https://jul2023.archive.ensembl.org 110 ## 8 Ensembl 109 Feb 2023 https://feb2023.archive.ensembl.org 109 ## 9 Ensembl 108 Oct 2022 https://oct2022.archive.ensembl.org 108 ## 10 Ensembl 107 Jul 2022 https://jul2022.archive.ensembl.org 107 ## current_release ## 1 ## 2 * ## 3 ## 4 ## 5 ## 6 ## 7 ## 8 ## 9 ## 10 # Example: pin to Ensembl 114 ensembl &lt;- useEnsembl(biomart = &quot;ensembl&quot;,version = params$ensembl_version) If you do not pin versions: ensembl &lt;- useMart(&quot;ensembl&quot;) 4.3 3. List datasets and select human datasets &lt;- listDatasets(ensembl) # filter for human human &lt;- datasets[grep(datasets$dataset, pattern = &quot;hsapiens&quot;), ] human ## dataset description version ## 80 hsapiens_gene_ensembl Human genes (GRCh38.p14) GRCh38.p14 ensembl &lt;- useDataset(&quot;hsapiens_gene_ensembl&quot;, mart = ensembl) 4.4 4. Identify the correct filter Filters are your input ID type. all_filters &lt;- listFilters(ensembl) dim(all_filters) ## [1] 443 2 # search for Ensembl gene filters all_filters[grep(all_filters$name, pattern = &quot;ensembl_gene&quot;), ] ## name ## 54 ensembl_gene_id ## 55 ensembl_gene_id_version ## description ## 54 Gene stable ID(s) [e.g. ENSG00000000003] ## 55 Gene stable ID(s) with version [e.g. ENSG00000000003.17] For Ensembl gene IDs, use filter: ensembl_gene_id. 4.5 5. Identify the correct attributes Attributes are the output columns you want. all_attr &lt;- listAttributes(ensembl) all_attr[1:10,] ## name description page ## 1 ensembl_gene_id Gene stable ID feature_page ## 2 ensembl_gene_id_version Gene stable ID version feature_page ## 3 ensembl_transcript_id Transcript stable ID feature_page ## 4 ensembl_transcript_id_version Transcript stable ID version feature_page ## 5 ensembl_peptide_id Protein stable ID feature_page ## 6 ensembl_peptide_id_version Protein stable ID version feature_page ## 7 ensembl_exon_id Exon stable ID feature_page ## 8 description Gene description feature_page ## 9 chromosome_name Chromosome/scaffold name feature_page ## 10 start_position Gene start (bp) feature_page # search for HGNC searchAttributes(ensembl, &quot;hgnc&quot;) ## name description page ## 63 hgnc_symbol HGNC symbol feature_page ## 64 hgnc_id HGNC ID feature_page ## 95 hgnc_trans_name Transcript name ID feature_page Common attributes: ensembl_gene_id hgnc_symbol 4.6 6. Strip version suffixes (if present) strip_ensembl_version &lt;- function(x) sub(&quot;\\\\..*$&quot;, &quot;&quot;, x) ids &lt;- c(&quot;ENSG00000141510.17&quot;, &quot;ENSG00000157764.2&quot;) ids_clean &lt;- strip_ensembl_version(ids) ids_clean ## [1] &quot;ENSG00000141510&quot; &quot;ENSG00000157764&quot; 4.7 7. Run the query with getBM() map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ids_clean, mart = ensembl ) map ## ensembl_gene_id hgnc_symbol ## 1 ENSG00000141510 TP53 ## 2 ENSG00000157764 BRAF 4.8 8. Cache the mapping (recommended) cache_file &lt;- &quot;id_conversion.rds&quot; if (file.exists(cache_file)) { map &lt;- readRDS(cache_file) } else { map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ids_clean, mart = ensembl ) saveRDS(map, cache_file) } 4.9 9. Merge back into your data library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following object is masked from &#39;package:biomaRt&#39;: ## ## select ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union df &lt;- tibble(ensembl_gene_id = ids_clean, value = c(1, 2)) df_annot &lt;- left_join(df, map, by = &quot;ensembl_gene_id&quot;) df_annot ## # A tibble: 2 × 3 ## ensembl_gene_id value hgnc_symbol ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 ENSG00000141510 1 TP53 ## 2 ENSG00000157764 2 BRAF "],["worked-examples-with-beforeafter-tables.html", "Chapter 5 Worked examples with before/after tables 5.1 GSE233947", " Chapter 5 Worked examples with before/after tables This chapter shows what the data look like, what the IDs look like, and how the table changes once mapped. library(knitr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tibble) kable_head &lt;- function(x, n = 5, caption = NULL) { knitr::kable(utils::head(x, n), caption = caption) } strip_ensembl_version &lt;- function(x) sub(&quot;\\\\..*$&quot;, &quot;&quot;, x) 5.1 GSE233947 5.1.1 Raw data preview source(&quot;./fetch_geo_supp.R&quot;) fetch_geo_supp(gse = params$gse) ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_FeatureCounts_V31genes_RawCounts_ENSG.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_3CTG_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_20CTG_junctions.tsv.gz ## Using locally cached version of supplementary file(s) GSE233947 found here: ## data/GSE233947/GSE233947_modulize_NT_3CTG_junctions.tsv.gz path &lt;- file.path(&quot;data&quot;, params$gse) files &lt;- list.files(path, pattern = params$file_grep, full.names = TRUE, recursive = TRUE) kable_head(tibble(file = basename(files)), min(10, length(files)), paste(params$gse,&quot;: extracted file list (first 10)&quot;)) (#tab:get_data)GSE233947 : extracted file list (first 10) file GSE233947_FeatureCounts_V31genes_RawCounts_ENSG.tsv.gz GSE233947_modulize_3CTG_20CTG_junctions.tsv.gz GSE233947_modulize_NT_20CTG_junctions.tsv.gz GSE233947_modulize_NT_3CTG_junctions.tsv.gz Raw table preview library(readr) safe_read &lt;- function(file) { # First attempt: read as TSV df &lt;- tryCatch( readr::read_tsv(file, show_col_types = FALSE), error = function(e) NULL # catch fatal errors ) # If read_tsv failed entirely: if (is.null(df)) { message(&quot;TSV read failed — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If read_tsv returned but with parsing issues: probs &lt;- problems(df) if (nrow(probs) &gt; 0) { message(&quot;Parsing issues detected in TSV — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If everything was fine: return(df) } x &lt;- safe_read(files[1]) kable_head(x[, 1:min(6, ncol(x))], 5, paste(params$gse,&quot;: raw table preview&quot;)) (#tab:preview_raw)GSE233947 : raw table preview Gene T8657_900CTG_NT T8658_1150CTG_NT T8659_1450CTG_NT T8660_900CTG_20CTG T8661_1150CTG_20CTG ENSG00000108821 456397 486088 608151 2012962 379186 ENSG00000265150 170681 299425 286295 747000 210962 ENSG00000164692 169781 190854 263391 869194 180006 ENSG00000265735 78113 121697 113379 532435 112977 ENSG00000259001 55081 78811 73032 353442 100823 ID preview id_col &lt;- names(x)[1] ids &lt;- x[[1]] |&gt; as.character() kable_head(tibble(raw_id = head(ids, 10), stripped = strip_ensembl_version(head(ids, 10))), 10, paste(params$gse,&quot;: ID preview&quot;)) (#tab:id_preview)GSE233947 : ID preview raw_id stripped ENSG00000108821 ENSG00000108821 ENSG00000265150 ENSG00000265150 ENSG00000164692 ENSG00000164692 ENSG00000265735 ENSG00000265735 ENSG00000259001 ENSG00000259001 ENSG00000163359 ENSG00000163359 ENSG00000115414 ENSG00000115414 ENSG00000168542 ENSG00000168542 ENSG00000251562 ENSG00000251562 ENSG00000155657 ENSG00000155657 5.1.2 After mapping (Ensembl → HGNC) if (any(grepl(&quot;^ENSG&quot;, strip_ensembl_version(ids)))) { library(biomaRt) ensembl_ids &lt;- unique(strip_ensembl_version(ids)) ensembl &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ensembl_ids, mart = ensembl ) kable_head(map, 10, paste(params$gse,&quot;: mapping preview&quot;)) expr_mapped &lt;- x %&gt;% mutate(ensembl_gene_id = strip_ensembl_version(.data[[id_col]])) %&gt;% left_join(map, by = &quot;ensembl_gene_id&quot;) %&gt;% dplyr::select( ensembl_gene_id,hgnc_symbol, everything()) kable_head(expr_mapped[, 1:min(8, ncol(expr_mapped))], 5, paste(params$gse,&quot;: mapped table preview&quot;)) } (#tab:after_map)GSE233947 : mapped table preview ensembl_gene_id hgnc_symbol Gene T8657_900CTG_NT T8658_1150CTG_NT T8659_1450CTG_NT T8660_900CTG_20CTG T8661_1150CTG_20CTG ENSG00000108821 COL1A1 ENSG00000108821 456397 486088 608151 2012962 379186 ENSG00000265150 NA ENSG00000265150 170681 299425 286295 747000 210962 ENSG00000164692 COL1A2 ENSG00000164692 169781 190854 263391 869194 180006 ENSG00000265735 RN7SL5P ENSG00000265735 78113 121697 113379 532435 112977 ENSG00000259001 ENSG00000259001 55081 78811 73032 353442 100823 Summarize the mapping n_ensembl_total &lt;- expr_mapped %&gt;% distinct(ensembl_gene_id) %&gt;% nrow() n_mapped &lt;- expr_mapped %&gt;% filter(!is.na(hgnc_symbol), hgnc_symbol != &quot;&quot;) %&gt;% distinct(ensembl_gene_id) %&gt;% nrow() n_unmapped &lt;- n_ensembl_total - n_mapped mapping_summary &lt;- tibble::tibble( category = c(&quot;Total Ensembl IDs&quot;, &quot;Mapped to HGNC&quot;, &quot;Unmapped&quot;), n = c(n_ensembl_total, n_mapped, n_unmapped) ) mapping_summary ## # A tibble: 3 × 2 ## category n ## &lt;chr&gt; &lt;int&gt; ## 1 Total Ensembl IDs 62248 ## 2 Mapped to HGNC 40176 ## 3 Unmapped 22072 unmapped_ids &lt;- expr_mapped %&gt;% distinct(ensembl_gene_id, hgnc_symbol) %&gt;% filter(is.na(hgnc_symbol) | hgnc_symbol == &quot;&quot;) %&gt;% pull(ensembl_gene_id) %&gt;% unique() length(unmapped_ids) ## [1] 22072 library(stringr) unmapped_classified &lt;- tibble::tibble(id = unmapped_ids) %&gt;% mutate(type = case_when( str_detect(id, &quot;^ENSG\\\\d+$&quot;) ~ &quot;Ensembl gene ID (ENSG)&quot;, str_detect(id, &quot;^ENSG\\\\d+\\\\.\\\\d+$&quot;) ~ &quot;Ensembl gene ID with version (ENSG.x) — needs stripping&quot;, str_detect(id, &quot;^ENST\\\\d+&quot;) ~ &quot;Ensembl transcript ID (ENST) — wrong target for gene mapping&quot;, str_detect(id, &quot;^ENSP\\\\d+&quot;) ~ &quot;Ensembl protein ID (ENSP) — wrong target&quot;, str_detect(id, &quot;^ENS.*G\\\\d+&quot;) ~ &quot;Non-human Ensembl gene (e.g., ENSMUSG...) — wrong organism&quot;, str_detect(id, &quot;^ERCC-&quot;) ~ &quot;ERCC spike-in control — not a gene&quot;, str_detect(id, &quot;^MT-|^mt-&quot;) ~ &quot;Mitochondrial gene symbol (not Ensembl ID) — different ID system&quot;, str_detect(id, &quot;^\\\\d+$&quot;) ~ &quot;Entrez Gene ID — different ID system&quot;, TRUE ~ &quot;Other / unknown format&quot; )) unmapped_classified %&gt;% count(type) %&gt;% arrange(desc(n)) ## # A tibble: 1 × 2 ## type n ## &lt;chr&gt; &lt;int&gt; ## 1 Ensembl gene ID (ENSG) 22072 # Use the same mart/dataset as your mapping step: # ensembl &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) ensg_details &lt;- getBM( attributes = c( &quot;ensembl_gene_id&quot;, &quot;gene_biotype&quot;, &quot;external_gene_name&quot; ), filters = &quot;ensembl_gene_id&quot;, values = unmapped_ids, mart = ensembl ) head(ensg_details) ## ensembl_gene_id gene_biotype external_gene_name ## 1 ENSG00000093100 lncRNA ## 2 ENSG00000124593 protein_coding ## 3 ENSG00000124835 lncRNA ## 4 ENSG00000141979 protein_coding ## 5 ENSG00000149656 transcribed_unprocessed_pseudogene ## 6 ENSG00000151303 lncRNA Output the distribution of biotypes for the subset of ensembl ids that have no HGNC ID. library(ggplot2) x &lt;- ensg_details$gene_biotype x[is.na(x)] &lt;- &quot;Unknown&quot; # Base R counts table -&gt; data.frame tab &lt;- table(x) df_counts &lt;- data.frame( biotype = names(tab), n = as.integer(tab), stringsAsFactors = FALSE ) # Order by counts (ascending) for a nice horizontal bar chart df_counts &lt;- df_counts[order(df_counts$n,decreasing = TRUE), ] df_counts$biotype &lt;- factor(df_counts$biotype, levels = df_counts$biotype) #only include the top 20 biotypes df_counts &lt;- df_counts[1:min(10, nrow(df_counts)), ] ggplot(df_counts, aes(x = biotype, y = n, fill = biotype)) + geom_col(width = 0.8, color = &quot;grey20&quot;) + coord_flip() + scale_fill_brewer(palette = &quot;Set3&quot;, guide = &quot;none&quot;) + labs( x = NULL, y = &quot;Number of genes&quot;, title = &quot;Distribution of Gene Biotypes - \\ntop 10 types not mapped&quot; ) + theme_minimal(base_size = 13) + theme( plot.title.position = &quot;plot&quot;, panel.grid.major.y = element_blank() ) Would the mapping of these identifiers have been different if we used a different version of Ensembl? "],["exercises.html", "Chapter 6 Exercises 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 6.3 Exercise 3 -", " Chapter 6 Exercises These are intended to be done after completing the worked examples. 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 Using GSE119732, confirm whether the ID column contains Ensembl IDs with version suffixes. Extract the first 20 IDs. Count how many contain a .. Create a new column with versions stripped. Map the identifiers to HGNC symbols. 6.1.1 Helper functions # Load Library library(tibble) library(readr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union # Print first n from head kable_head &lt;- function(x, n = 5, caption = NULL) { knitr::kable(utils::head(x, n), caption = caption) } # Safe read files safe_read &lt;- function(file) { # First attempt: read as TSV df &lt;- tryCatch( readr::read_tsv(file, show_col_types = FALSE), error = function(e) NULL # catch fatal errors ) # If read_tsv failed entirely: if (is.null(df)) { message(&quot;TSV read failed — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If read_tsv returned but with parsing issues: probs &lt;- problems(df) if (nrow(probs) &gt; 0) { message(&quot;Parsing issues detected in TSV — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If everything was fine: return(df) } # Strip version number strip_ensembl_version &lt;- function(ids) sub(&quot;\\\\..*$&quot;, &quot;&quot;, ids) # Load fetching function source(&quot;./fetch_geo_supp.R&quot;) 6.1.2 Question 1 gse &lt;- &quot;GSE119732&quot; pattern &lt;- &quot;GSE119732.*\\\\.gz&quot; path &lt;- file.path(&quot;data&quot;, gse) files &lt;- list.files(path, pattern = pattern, full.names = TRUE, recursive = TRUE) kable_head(tibble(file = basename(files)), min(10, length(files)), paste(gse,&quot;: extracted file list (first 10)&quot;)) Table 6.1: GSE119732 : extracted file list (first 10) file GSE119732_count_table_RNA_seq.txt.gz x &lt;- safe_read(files[1]) kable_head(x[, 1:min(6, ncol(x))], 20, paste(gse,&quot;: raw table preview&quot;)) Table 6.1: GSE119732 : raw table preview gene_id A1 A2 A3 A4 B1 ENSG00000223972.5 0 0 0 0 0 ENSG00000227232.5 79 119 84 50 80 ENSG00000278267.1 17 10 22 19 19 ENSG00000243485.4 0 0 0 0 0 ENSG00000237613.2 0 0 0 0 0 ENSG00000268020.3 0 0 0 0 0 ENSG00000240361.1 0 0 0 0 0 ENSG00000186092.4 0 0 0 0 0 ENSG00000238009.6 0 0 0 1 1 ENSG00000239945.1 0 0 0 0 0 ENSG00000233750.3 0 0 0 0 0 ENSG00000268903.1 7 10 9 6 29 ENSG00000269981.1 17 11 14 4 27 ENSG00000239906.1 0 0 1 0 0 ENSG00000241860.6 6 19 12 8 60 ENSG00000222623.1 0 0 0 0 0 ENSG00000241599.1 0 0 0 0 0 ENSG00000279928.1 8 5 9 6 0 ENSG00000279457.3 282 298 334 205 156 ENSG00000273874.1 0 0 0 0 0 6.1.3 Question 2 # Extract the first 20 IDs first_20_ids &lt;- head(x$gene_id, 20) # Count how many of the first 20 contain a &quot;.&quot; dot_count &lt;- sum(grepl(&quot;\\\\.&quot;, first_20_ids)) print(paste(&quot;Number of IDs with version suffixes in first 20:&quot;, dot_count)) ## [1] &quot;Number of IDs with version suffixes in first 20: 20&quot; # Count how many total contain a &quot;.&quot; dot_count &lt;- sum(grepl(&quot;\\\\.&quot;, x$gene_id)) print(paste(&quot;Total number of IDs with version suffixes:&quot;, dot_count)) ## [1] &quot;Total number of IDs with version suffixes: 58037&quot; All 20 from the 1st 20 have a “.”, all 58037 ids of this whole set have a “.”. 6.1.4 Question 3 # Apply to your tibble &#39;x&#39; id_col &lt;- names(x)[1] ids &lt;- x[[1]] |&gt; as.character() kable_head(tibble(raw_id = head(ids, 10), stripped = strip_ensembl_version(head(ids, 10))), 10, paste(gse,&quot;: ID preview&quot;)) Table 6.2: GSE119732 : ID preview raw_id stripped ENSG00000223972.5 ENSG00000223972 ENSG00000227232.5 ENSG00000227232 ENSG00000278267.1 ENSG00000278267 ENSG00000243485.4 ENSG00000243485 ENSG00000237613.2 ENSG00000237613 ENSG00000268020.3 ENSG00000268020 ENSG00000240361.1 ENSG00000240361 ENSG00000186092.4 ENSG00000186092 ENSG00000238009.6 ENSG00000238009 ENSG00000239945.1 ENSG00000239945 6.1.5 Question 4 if (any(grepl(&quot;^ENSG&quot;, strip_ensembl_version(ids)))) { library(biomaRt) ensembl_ids &lt;- unique(strip_ensembl_version(ids)) ensembl &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ensembl_ids, mart = ensembl ) kable_head(map, 10, paste(gse,&quot;: mapping preview&quot;)) expr_mapped &lt;- x %&gt;% mutate(ensembl_gene_id = strip_ensembl_version(.data[[id_col]])) %&gt;% left_join(map, by = &quot;ensembl_gene_id&quot;) %&gt;% dplyr::select( ensembl_gene_id,hgnc_symbol, everything()) kable_head(expr_mapped[, 1:min(8, ncol(expr_mapped))], 5, paste(gse,&quot;: mapped table preview&quot;)) } ## Warning in left_join(., map, by = &quot;ensembl_gene_id&quot;): Detected an unexpected many-to-many relationship between `x` and `y`. ## ℹ Row 29117 of `x` matches multiple rows in `y`. ## ℹ Row 53969 of `y` matches multiple rows in `x`. ## ℹ If a many-to-many relationship is expected, set `relationship = ## &quot;many-to-many&quot;` to silence this warning. Table 6.3: GSE119732 : mapped table preview ensembl_gene_id hgnc_symbol gene_id A1 A2 A3 A4 B1 ENSG00000223972 DDX11L1 ENSG00000223972.5 0 0 0 0 0 ENSG00000227232 WASH7P ENSG00000227232.5 79 119 84 50 80 ENSG00000278267 MIR6859-1 ENSG00000278267.1 17 10 22 19 19 ENSG00000243485 MIR1302-2HG ENSG00000243485.4 0 0 0 0 0 ENSG00000237613 FAM138A ENSG00000237613.2 0 0 0 0 0 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 Using GSE122380, confirm whether the ID column contains Ensembl IDs with version suffixes. Extract the first 20 IDs. Create a new column with versions stripped. Map the identifiers to HGNC symbols. What is different about this file? 6.2.1 Question 1 gse &lt;- &quot;GSE122380&quot; pattern &lt;- &quot;GSE122380.*\\\\.gz&quot; path &lt;- file.path(&quot;data&quot;, gse) files &lt;- list.files(path, pattern = pattern, full.names = TRUE, recursive = TRUE) kable_head(tibble(file = basename(files)), min(10, length(files)), paste(gse,&quot;: extracted file list (first 10)&quot;)) Table 6.4: GSE122380 : extracted file list (first 10) file GSE122380_raw_counts.txt.gz x &lt;- safe_read(files[1]) ## Warning: One or more parsing issues, call `problems()` on your data frame for details, ## e.g.: ## dat &lt;- vroom(...) ## problems(dat) ## Parsing issues detected in TSV — reading as space-delimited file instead. kable_head(x[, 1:min(6, ncol(x))], 20, paste(gse,&quot;: raw table preview&quot;)) Table 6.4: GSE122380 : raw table preview Gene_id 18489_0 18489_10 18489_11 18489_12 18489_13 ENSG00000000419 825 549 576 599 607 ENSG00000000457 175 238 279 254 327 ENSG00000000460 337 103 120 124 154 ENSG00000000938 7 1 0 0 0 ENSG00000000971 0 3 5 10 4 ENSG00000001036 2251 860 819 732 1071 ENSG00000001084 980 833 694 615 959 ENSG00000001167 886 991 889 1164 1000 ENSG00000001460 239 215 142 171 225 ENSG00000001461 402 798 664 777 907 ENSG00000001561 336 293 207 195 309 ENSG00000001617 1850 955 472 1174 737 ENSG00000001626 100 55 46 101 52 ENSG00000001629 1266 1055 1037 1255 1248 ENSG00000001630 157 176 150 130 179 ENSG00000001631 641 843 812 861 984 ENSG00000002016 403 543 354 428 464 ENSG00000002330 131 299 301 298 374 ENSG00000002549 742 869 902 713 973 ENSG00000002587 11 50 51 54 30 6.2.2 Question 2 # Extract the first 20 IDs first_20_ids &lt;- head(x$gene_id, 20) ## Warning: Unknown or uninitialised column: `gene_id`. # Count how many of the first 20 contain a &quot;.&quot; dot_count &lt;- sum(grepl(&quot;\\\\.&quot;, first_20_ids)) print(paste(&quot;Number of IDs with version suffixes in first 20:&quot;, dot_count)) ## [1] &quot;Number of IDs with version suffixes in first 20: 0&quot; # Count how many total contain a &quot;.&quot; dot_count &lt;- sum(grepl(&quot;\\\\.&quot;, x$gene_id)) ## Warning: Unknown or uninitialised column: `gene_id`. print(paste(&quot;Total number of IDs with version suffixes:&quot;, dot_count)) ## [1] &quot;Total number of IDs with version suffixes: 0&quot; 0 from the 1st 20 have a “.”, all ids of this whole set dpn’t have a “.”. 6.2.3 Question 3 # Define the ID column name id_col &lt;- names(x)[1] ids &lt;- x[[1]] |&gt; as.character() # Since IDs don&#39;t have dots, we use them directly if (any(grepl(&quot;^ENSG&quot;, ids))) { library(biomaRt) library(dplyr) ensembl_ids &lt;- unique(ids) ensembl &lt;- useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) # Fetch the mapping map &lt;- getBM( attributes = c(&quot;ensembl_gene_id&quot;, &quot;hgnc_symbol&quot;), filters = &quot;ensembl_gene_id&quot;, values = ensembl_ids, mart = ensembl ) kable_head(map, 10, paste(gse, &quot;: mapping preview (cleaned)&quot;)) # Join using the original IDs directly expr_mapped &lt;- x %&gt;% mutate(ensembl_gene_id = .data[[id_col]]) %&gt;% left_join(map, by = &quot;ensembl_gene_id&quot;) %&gt;% dplyr::select(ensembl_gene_id,hgnc_symbol, everything()) # Preview the final table kable_head(expr_mapped[, 1:min(8, ncol(expr_mapped))], 10, paste(gse, &quot;: mapped table preview&quot;)) } Table 6.5: GSE122380 : mapped table preview ensembl_gene_id hgnc_symbol Gene_id 18489_0 18489_10 18489_11 18489_12 18489_13 ENSG00000000419 DPM1 ENSG00000000419 825 549 576 599 607 ENSG00000000457 SCYL3 ENSG00000000457 175 238 279 254 327 ENSG00000000460 FIRRM ENSG00000000460 337 103 120 124 154 ENSG00000000938 FGR ENSG00000000938 7 1 0 0 0 ENSG00000000971 CFH ENSG00000000971 0 3 5 10 4 ENSG00000001036 FUCA2 ENSG00000001036 2251 860 819 732 1071 ENSG00000001084 GCLC ENSG00000001084 980 833 694 615 959 ENSG00000001167 NFYA ENSG00000001167 886 991 889 1164 1000 ENSG00000001460 STPG1 ENSG00000001460 239 215 142 171 225 ENSG00000001461 NIPAL3 ENSG00000001461 402 798 664 777 907 6.2.4 Question 4 GSE122380 uses stable Ensembl IDs without version suffixes, whereas your previous file used versioned IDs (e.g., .5) that required stripping, which made is simpler to map to HGNC. 6.3 Exercise 3 - Can you use the worked example to process the above two GEO records? How? Yes — you can process both GEO records using the exact same workflow but with minor change in variables and remove the stripping version number step if not needed. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
