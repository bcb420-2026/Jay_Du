[["index.html", "Normalization (BCB420 Lecture) Welcome 0.1 Learning goals 0.2 Example datasets", " Normalization (BCB420 Lecture) Ruth Isserlin Welcome This bookdown module turns the Lecture – Normalization slides into a hands-on, reproducible mini-book. 0.1 Learning goals By the end, learners should be able to: Visualize sample distributions with boxplots and density plots. Apply appropriate normalization methods for: bulk RNA-seq (e.g., TMM, DESeq2 size factors) single-cell RNA-seq (library-size scaling + log1p; conceptually) Evaluate normalization with diagnostic plots. 0.2 Example datasets We re-use the same GEO series as practical examples: GSE119732 (bulk RNA-seq) "],["what-is-normalization.html", "Chapter 1 What is normalization?", " Chapter 1 What is normalization? Normalization adjusts raw measurements so that samples become comparable by removing unwanted technical effects while preserving true biological signal. In sequencing-based expression data, raw counts reflect both: the amount of RNA (biology) sequencing depth, composition, gene length, etc. (technology) Normalization is one of the first steps in any analysis pipeline and can substantially affect downstream results. "],["technical-vs-biological-variation.html", "Chapter 2 Technical vs biological variation 2.1 Technical variation 2.2 Biological variation", " Chapter 2 Technical vs biological variation 2.1 Technical variation Examples: different sequencing depths (library sizes) batch effects (day, reagent, operator) gene length and GC content biases We aim to control/correct these. 2.2 Biological variation Differences due to the biology we care about: condition, tissue, genotype treatment, disease status Normalization should reduce technical variation while leaving biological variation intact. "],["visualizing-distributions.html", "Chapter 3 Visualizing distributions 3.1 load Some data 3.2 Boxplots 3.3 Density plots", " Chapter 3 Visualizing distributions Before choosing a normalization method, inspect data distributions. 3.1 load Some data library(GEOquery) ## Loading required package: Biobase ## Loading required package: BiocGenerics ## Loading required package: generics ## ## Attaching package: &#39;generics&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, ## setequal, union ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, aperm, append, as.data.frame, basename, cbind, ## colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find, ## get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique, ## unsplit, which.max, which.min ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## Setting options(&#39;download.file.method.GEOquery&#39;=&#39;auto&#39;) ## Setting options(&#39;GEOquery.inmemory.gpl&#39;=FALSE) library(knitr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following object is masked from &#39;package:Biobase&#39;: ## ## combine ## The following objects are masked from &#39;package:BiocGenerics&#39;: ## ## combine, intersect, setdiff, setequal, union ## The following object is masked from &#39;package:generics&#39;: ## ## explain ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tibble) if(!require(tidyverse)){ install.packages(&quot;tidyvers&quot;,dependencies = FALSE) } ## Loading required package: tidyverse ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ forcats 1.0.1 ✔ readr 2.1.6 ## ✔ ggplot2 4.0.1 ✔ stringr 1.6.0 ## ✔ lubridate 1.9.5 ✔ tidyr 1.3.2 ## ✔ purrr 1.2.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::combine() masks Biobase::combine(), BiocGenerics::combine() ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ✖ ggplot2::Position() masks BiocGenerics::Position(), base::Position() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(tidyverse) gse &lt;- &quot;GSE119732&quot; source(&quot;./supp_functions.R&quot;) fetch_geo_supp(gse = gse) path &lt;- file.path(&quot;data&quot;, gse) files &lt;- list.files(path, pattern = &quot;\\\\.txt.gz$|\\\\.tsv.gz$|\\\\.csv.gz$&quot;, full.names = TRUE, recursive = TRUE) Raw table preview library(readr) safe_read &lt;- function(file) { # First attempt: read as TSV df &lt;- tryCatch( readr::read_tsv(file, show_col_types = FALSE), error = function(e) NULL # catch fatal errors ) # If read_tsv failed entirely: if (is.null(df)) { message(&quot;TSV read failed — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If read_tsv returned but with parsing issues: probs &lt;- problems(df) if (nrow(probs) &gt; 0) { message(&quot;Parsing issues detected in TSV — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If everything was fine: return(df) } x &lt;- safe_read(files[1]) kable_head(x[, 1:min(6, ncol(x))], 5, paste(gse,&quot;: raw table preview&quot;)) (#tab:preview_raw)GSE119732 : raw table preview gene_id A1 A2 A3 A4 B1 ENSG00000223972.5 0 0 0 0 0 ENSG00000227232.5 79 119 84 50 80 ENSG00000278267.1 17 10 22 19 19 ENSG00000243485.4 0 0 0 0 0 ENSG00000237613.2 0 0 0 0 0 3.2 Boxplots library(tidyverse) # suppose &#39;mat&#39; is a gene x sample matrix (numeric) plot_box &lt;- function(mat, main = &quot;&quot;, ylab = &quot;log2(counts+1)&quot;) { df &lt;- as.data.frame(mat) df_long &lt;- df |&gt; mutate(gene = rownames(df)) |&gt; pivot_longer(-gene, names_to = &quot;sample&quot;, values_to = &quot;value&quot;) |&gt; mutate(value = log2(value + 1)) ggplot(df_long, aes(x = sample, y = value)) + geom_boxplot(outlier.size = 0.2) + theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + labs(title = main, x = &quot;Sample&quot;, y = ylab) } plot_box(x[,2:ncol(x)]) 3.3 Density plots plot_density &lt;- function(mat, main = &quot;&quot;) { df &lt;- as.data.frame(mat) df_long &lt;- df |&gt; mutate(gene = rownames(df)) |&gt; pivot_longer(-gene, names_to = &quot;sample&quot;, values_to = &quot;value&quot;) |&gt; mutate(value = log2(value + 1)) ggplot(df_long, aes(x = value, colour = sample)) + geom_density() + theme_bw() + labs(title = main, x = &quot;log2(counts+1)&quot;, y = &quot;Density&quot;) + guides(colour = &quot;none&quot;) } plot_density(x[,2:ncol(x)]) "],["normalization-methods.html", "Chapter 4 Normalization methods 4.1 Library-size scaling 4.2 Distribution-based normalization 4.3 RNA-seq composition-aware methods 4.4 Single-cell note", " Chapter 4 Normalization methods Different assays require different methods. 4.1 Library-size scaling The simplest approach divides each sample by its total counts (or reads) to account for sequencing depth. 4.1.1 Counts-per-million (CPM) There are other versions of this type of normalization (RPKM, FPKM ,TPM,…) - all of them try to normalize for the library size (the number of reads in a given experiment) but some of them incorporate other factors as well. CPM - normalizes for just library size. TPM - normalzie for gene length, then library size. FPKM/RPKM - similiar but one uses reads and the other fragments. normalizes for gene length and library size at the same time. TPM is preferred. 4.2 Distribution-based normalization Methods like quantile normalization force sample distributions to match and are common in microarrays. 4.3 RNA-seq composition-aware methods Two widely used methods: TMM (edgeR): computes scaling factors to adjust effective library sizes. RLE / size factors (DESeq2): median-of-ratios approach. 4.3.1 edgeR: TMM TMM looks at most genes, ignores the weird ones, figures out how different two samples really are, and uses that to scale the samples so they’re comparable. library(edgeR) dge &lt;- DGEList(counts = counts) dge &lt;- calcNormFactors(dge, method = &quot;TMM&quot;) logcpm &lt;- cpm(dge, log = TRUE, prior.count = 1) 4.3.2 DESeq2: size factors RLE finds what “most genes” are doing compared to a typical sample. It adjusts each sample so that the median gene looks the same in all samples. library(DESeq2) dds &lt;- DESeqDataSetFromMatrix(countData = counts, colData = meta, design = ~ condition) dds &lt;- estimateSizeFactors(dds) norm_counts &lt;- counts(dds, normalized = TRUE) 4.4 Single-cell note In scRNA-seq, normalization often starts with per-cell library-size scaling followed by log1p and sometimes variance stabilization. The concepts (make samples comparable; avoid composition artifacts) are the same. "],["worked-normalization-examples.html", "Chapter 5 Worked normalization examples 5.1 Setup: download supplementary files 5.2 load Some data 5.3 Example 1: GSE119732 5.4 Convert the raw counts to Counts per million (CPM) 5.5 filter out lowly expressed genes 5.6 Incorporate a design matrix - description of the samples. 5.7 Normalize Dataset using TMM 5.8 Look at the distribution of our samples in 2D space 5.9 Normalize the Dataset using RLE", " Chapter 5 Worked normalization examples We will demonstrate exploratory normalization steps on the expression datasets. 5.1 Setup: download supplementary files 5.2 load Some data Raw table preview library(readr) safe_read &lt;- function(file) { # First attempt: read as TSV df &lt;- tryCatch( readr::read_tsv(file, show_col_types = FALSE), error = function(e) NULL # catch fatal errors ) # If read_tsv failed entirely: if (is.null(df)) { message(&quot;TSV read failed — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If read_tsv returned but with parsing issues: probs &lt;- problems(df) if (nrow(probs) &gt; 0) { message(&quot;Parsing issues detected in TSV — reading as space-delimited file instead.&quot;) return(readr::read_table(file, show_col_types = FALSE)) } # If everything was fine: return(df) } x &lt;- safe_read(files[1]) kable_head(x[, 1:min(6, ncol(x))], 5, paste(gse,&quot;: raw table preview&quot;)) (#tab:preview_raw)GSE233947 : raw table preview Gene T8657_900CTG_NT T8658_1150CTG_NT T8659_1450CTG_NT T8660_900CTG_20CTG T8661_1150CTG_20CTG ENSG00000108821 456397 486088 608151 2012962 379186 ENSG00000265150 170681 299425 286295 747000 210962 ENSG00000164692 169781 190854 263391 869194 180006 ENSG00000265735 78113 121697 113379 532435 112977 ENSG00000259001 55081 78811 73032 353442 100823 5.3 Example 1: GSE119732 Before doing anything to this data. What does it look like? plot_box(x[,2:ncol(x)]) plot_density(x[,2:ncol(x)]) 5.4 Convert the raw counts to Counts per million (CPM) library(edgeR) x_cpm &lt;- cpm(y = x[,2:ncol(x)]) plot_box(x_cpm,main = &quot;CPM - all genes&quot;) Visualize as a density plot as well plot_density(x_cpm,main = &quot;CPM - all genes, NO design&quot;) There are a lot of genes that have zero expression. That is the majority of them. So we need to get rid of them. 5.5 filter out lowly expressed genes to_remove &lt;- edgeR::filterByExpr(x_cpm,min.count = 3) x_cpm_filtered &lt;- x_cpm[to_remove,] plot_box(x_cpm_filtered,main = &quot;CPM filtered out lowly expressed - \\nNO design matrix&quot;) visualize this as density plot as well. plot_density(x_cpm_filtered,main = &quot;CPM filtered out lowly expressed - \\n - NO design matrix&quot;) 5.6 Incorporate a design matrix - description of the samples. The above was usingn all of the samples the same but this dataset has varying sample types. I might be hard to figure it out just from column names as they are not so informative but let’s just guess colnames(x) ## [1] &quot;Gene&quot; &quot;T8657_900CTG_NT&quot; &quot;T8658_1150CTG_NT&quot; ## [4] &quot;T8659_1450CTG_NT&quot; &quot;T8660_900CTG_20CTG&quot; &quot;T8661_1150CTG_20CTG&quot; ## [7] &quot;T8662_1450CTG_20CTG&quot; &quot;T8663_900CTG_3CTG&quot; &quot;T8664_1150CTG_3CTG&quot; ## [10] &quot;T8665_1450CTG_3CTG&quot; #design matrix - samples &lt;- colnames(x)[2:ncol(x)] patient &lt;- unlist(lapply(samples,FUN = function(x){unlist(strsplit(x,split = &quot;_&quot;))[2]})) celltype &lt;- unlist(lapply(samples,FUN = function(x){unlist(strsplit(x,split = &quot;_&quot;))[3]})) sample_data &lt;- data.frame(samples, patient, celltype) design &lt;- model.matrix(~ 0 + celltype,data = sample_data) rownames(design) &lt;- sample_data$samples colnames(design) &lt;- paste0(&quot;celltype&quot;, levels(factor(celltype))) design ## celltype20CTG celltype3CTG celltypeNT ## T8657_900CTG_NT 0 0 1 ## T8658_1150CTG_NT 0 0 1 ## T8659_1450CTG_NT 0 0 1 ## T8660_900CTG_20CTG 1 0 0 ## T8661_1150CTG_20CTG 1 0 0 ## T8662_1450CTG_20CTG 1 0 0 ## T8663_900CTG_3CTG 0 1 0 ## T8664_1150CTG_3CTG 0 1 0 ## T8665_1450CTG_3CTG 0 1 0 ## attr(,&quot;assign&quot;) ## [1] 1 1 1 ## attr(,&quot;contrasts&quot;) ## attr(,&quot;contrasts&quot;)$celltype ## [1] &quot;contr.treatment&quot; Filter use design information to_remove_withdesign &lt;- edgeR::filterByExpr(x_cpm, min.count = 3, design = design) x_cpm_filtered_withdesign &lt;- x_cpm[to_remove_withdesign,] colnames(x_cpm_filtered_withdesign ) &lt;- paste(sample_data$celltype, 1:nrow(sample_data),sep = &quot;_&quot;) plot_box(x_cpm_filtered_withdesign, main = &quot;CPM filtered out lowly expressed - \\n - with design matrix&quot;) plot_density(x_cpm_filtered_withdesign,main = &quot;CPM filtered out lowly expressed - \\n - with design matrix&quot;) 5.7 Normalize Dataset using TMM library(edgeR) dge &lt;- DGEList(counts = x[,2:ncol(x)]) dge_filtered &lt;- dge[filterByExpr(dge),] dge_filtered &lt;- calcNormFactors(dge_filtered , method = &quot;TMM&quot;) norm_cpm &lt;- cpm(dge_filtered , log = FALSE, prior.count = 1) plot_box(norm_cpm) plot_density(norm_cpm) 5.8 Look at the distribution of our samples in 2D space y &lt;- dge_filtered plotMDS(y, top = 500, labels = colnames(y), col = as.integer(y$samples$group)) legend(&quot;topright&quot;, legend = levels(y$samples$group), col = seq_along(levels(y$samples$group)), pch = 16, bty = &quot;n&quot;) Now incorporate the design into the process dge &lt;- DGEList(counts = x[,2:ncol(x)],group = sample_data$celltype) dge_filtered &lt;- dge[filterByExpr(dge),] dge_filtered &lt;- calcNormFactors(dge_filtered , method = &quot;TMM&quot;) norm_cpm &lt;- cpm(dge_filtered , log = FALSE, prior.count = 1) plot_box(norm_cpm) plot_density(norm_cpm) y &lt;- dge_filtered plotMDS(y, top = 500, labels = sample_data$celltype,#colnames(y), col = as.integer(y$samples$group)) legend(&quot;topright&quot;, legend = levels(y$samples$group), col = seq_along(levels(y$samples$group)), pch = 16, bty = &quot;n&quot;) Now incorporate the design into the process dge &lt;- DGEList(counts = x[,2:ncol(x)],group = sample_data$patient) dge_filtered &lt;- dge[filterByExpr(dge),] dge_filtered &lt;- calcNormFactors(dge_filtered , method = &quot;TMM&quot;) norm_cpm &lt;- cpm(dge_filtered , log = FALSE, prior.count = 1) plot_box(norm_cpm) plot_density(norm_cpm) y &lt;- dge_filtered plotMDS(y, top = 500, labels = sample_data$patient,# colnames(y), col = as.integer(y$samples$group)) legend(&quot;topright&quot;, legend = levels(y$samples$group), col = seq_along(levels(y$samples$group)), pch = 16, bty = &quot;n&quot;) 5.9 Normalize the Dataset using RLE library(DESeq2) counts &lt;- x[,2:ncol(x)] keep &lt;- rowSums(counts &gt;= 10) &gt;= 2 counts_filtered &lt;- counts[keep, ] dds &lt;- DESeqDataSetFromMatrix(countData = counts_filtered, colData = sample_data, design = design) dds &lt;- estimateSizeFactors(dds) norm_counts &lt;- counts(dds, normalized = TRUE) plot_box(norm_counts) plot_density(norm_counts) "],["exercises.html", "Chapter 6 Exercises 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 6.3 Exercise 3 -", " Chapter 6 Exercises These are intended to be done after completing the worked examples. 6.1 Exercise 1 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119732 Using GSE119732, Map the distribution of the samples as a box plot and a density plot using only the raw data. Add colours to the plot separating the different variables in the model Filter out lowly expressed genes and re plot the distributions. 6.2 Exercise 2 — https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122380 Using GSE122380, confirm whether the ID column contains Ensembl IDs with version suffixes. Map the distribution of the samples as a box plot and a density plot using only the raw data. Add colours to the plot separating the different variables in the model Filter out lowly expressed genes and re plot the distributions. 6.3 Exercise 3 - Can you use the worked example to process the above two GEO records? How? "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
